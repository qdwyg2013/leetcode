## 1.使用场景
当遇到了要快速判断一个元素是否出现在集合里的时候，就要考虑哈希法。

但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组set或者是map来存放数据，才能实现快速的查找。

## 2.数组作为哈希表
使用数组来做哈希的题目，都限制了数值的大小。
若题目中只有小写字母，或者数值大小在[0- 10000] 之内等等，这就是暗示我们使用数组。

## 3.set作为哈希表
使用数组的局限：
+ 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。
+ 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

HashSet：采用**哈希表**来实现的，其中的元素没有按顺序排列（同C++的 std::unordered_set）
TreeSet：采用**红黑树算法**来实现的，元素是按顺序进行排列（同C++的 std::set）
LinkedHashSet：采用的**哈希表+链表结构**。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复。

## 4.map作为哈希表
使用数组和set来做哈希法的局限。
+ 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
+ set是一个集合，里面放的元素只能是一个key，而map是一种<key, value>的结构。

HashMap：采用**哈希表**来实现的，其中的元素没有按顺序排列（同C++的 std::unordered_map）
TreeMap：采用**红黑树算法**来实现的，元素是按顺序进行排列（同C++的 std::map）
LinkedHashMap：采用的**哈希表+链表结构**。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复。


````
    // 通过取余，获取n最后一位数字
    int remainder = n % 10;
    // 通过求商，获取n前n-1位数字
    n /= 10;
````

